<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Signed Distance Field Renderer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>

    <!-- Vertex Shader: Renders a full-screen quad -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <!-- Fragment Shader: The Raymarcher -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float; // highp for more precision in distance calculations

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec3 u_cameraPos;
        uniform vec3 u_cameraLookAt;
        uniform float u_cameraZoom; // Effectively FOV control

        // --- SDF Primitives ---
        float sdSphere(vec3 p, float s) {
            return length(p) - s;
        }

        float sdBox(vec3 p, vec3 b) {
            vec3 q = abs(p) - b;
            return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
        }

        float sdTorus(vec3 p, vec2 t) { // t.x = major radius, t.y = minor radius
            vec2 q = vec2(length(p.xz) - t.x, p.y);
            return length(q) - t.y;
        }

        // Heart SDF based on the implicit equation:
        // (x^2 + (9/4)*(y^2) + z^2 -1)^3 - (x^2)*(z^3) -(9/200)*(y^2)*(z^3) = 0
        // p_obj is in object space, centered at origin.
        // The function returns f(p_obj), which is not a true SDF.
        // It needs to be scaled by a normalization factor and object scale in the map function.
        float sdHeartImplicit(vec3 p_obj) {
            float x2 = p_obj.x * p_obj.x;
            float y2 = p_obj.y * p_obj.y;
            float z2 = p_obj.z * p_obj.z;
            float z3 = z2 * p_obj.z; // p_obj.z^3

            float term1_base = x2 + (9.0/4.0)*y2 + z2 - 1.0;
            float term1 = term1_base * term1_base * term1_base;
            
            float term2 = x2 * z3;
            float term3 = (9.0/200.0) * y2 * z3;

            return term1 - term2 - term3;
        }
        
        // --- SDF Operations ---
        float opUnion(float d1, float d2) { return min(d1, d2); }
        float opSubtraction(float d1, float d2) { return max(d1, -d2); }
        float opIntersection(float d1, float d2) { return max(d1, d2); }

        // Smooth minimum (for smooth union)
        float opSmoothUnion( float d1, float d2, float k ) {
            float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
            return mix( d2, d1, h ) - k*h*(1.0-h);
        }

        // --- Scene Definition ---
        // This function returns vec2(signed_distance, material_id)
        vec2 map(vec3 p) {
            float sceneDist = 1e10; // Large number (effectively infinity)
            float materialID = 0.0; // 0: default/ground, 1: sphere, 2: box, 3: torus, 4: heart

            // Pulsating sphere
            float sphereRadius = 0.8 + 0.2 * sin(u_time * 2.0);
            vec3 spherePos = vec3(0.0, sphereRadius, 0.0); 
            float sphereDist = sdSphere(p - spherePos, sphereRadius);
            if (sphereDist < sceneDist) {
                sceneDist = sphereDist;
                materialID = 1.0;
            }
            
            // Rotating Box
            vec3 boxPos = vec3(2.5, 0.5, 0.0);
            vec3 boxSize = vec3(0.5, 0.5, 0.5);
            float boxAngle = u_time * 0.5;
            mat2 rotY_box = mat2(cos(boxAngle), -sin(boxAngle), sin(boxAngle), cos(boxAngle));
            vec3 pBox = p - boxPos;
            pBox.xz = rotY_box * pBox.xz;
            float boxDist = sdBox(pBox, boxSize);
             if (boxDist < sceneDist) {
                sceneDist = boxDist;
                materialID = 2.0;
            }

            // Torus
            vec3 torusPos = vec3(-2.0, 0.6, 0.5);
            vec2 torusRadii = vec2(0.8, 0.25);
            float torusDist = sdTorus(p - torusPos, torusRadii);
             if (torusDist < sceneDist) {
                sceneDist = torusDist;
                materialID = 3.0;
            }

            // 3D Heart
            vec3 heartPos = vec3(0.0, 1.0, -2.0); 
            float heartScale = 0.8;               
            
            vec3 p_to_heart_origin = p - heartPos;
            
            // Transform p to heart's local, scaled space
            vec3 p_heart_local = p_to_heart_origin / heartScale;
            
            float raw_heart_val = sdHeartImplicit(p_heart_local);
            
            float heartSDF_NormalizationFactor = 0.3; 
            float heartDist = raw_heart_val * heartScale * heartSDF_NormalizationFactor;

            if (heartDist < sceneDist) {
                sceneDist = heartDist;
                materialID = 4.0; 
            }

            // Ground plane
            float planeDist = p.y + 0.0; // Plane at y = 0
             if (planeDist < sceneDist) {
                sceneDist = planeDist;
                materialID = 0.0; // Ground material
            }

            return vec2(sceneDist, materialID);
        }

        // --- Normal Calculation ---
        vec3 calcNormal(vec3 p) {
            const float epsilon = 0.001; 
            vec2 e = vec2(epsilon, 0.0);
            
            vec3 normal = vec3(
                map(p + e.xyy).x - map(p - e.xyy).x,
                map(p + e.yxy).x - map(p - e.yxy).x,
                map(p + e.yyx).x - map(p - e.yyx).x
            );
            return normalize(normal);
        }

        // --- Raymarching ---
        const int MAX_STEPS = 100; 
        const float MAX_DIST = 100.0; 
        const float HIT_THRESHOLD = 0.001; 

        vec2 raymarch(vec3 ro, vec3 rd) {
            float t = 0.0; 
            float currentMaterialID = -1.0; // Use a local var for material ID during march

            for (int i = 0; i < MAX_STEPS; i++) {
                vec3 p_current = ro + t * rd;
                vec2 map_result = map(p_current);
                float dist_to_surface = map_result.x;
                
                if (dist_to_surface < HIT_THRESHOLD) {
                    currentMaterialID = map_result.y; 
                    return vec2(t, currentMaterialID); 
                }
                t += dist_to_surface;
                if (t > MAX_DIST) {
                    break; 
                }
            }
            return vec2(MAX_DIST, -1.0); // Missed
        }

        // --- Camera Ray Generation ---
        vec3 getRayDirection(vec2 uv, vec3 camPos, vec3 lookAt, float zoom) {
            vec3 f = normalize(lookAt - camPos); 
            vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), f)); 
            vec3 u = cross(f, r); 

            return normalize(f * zoom + uv.x * r + uv.y * u);
        }
        
        // --- Lighting ---
        vec3 applyLighting(vec3 p, vec3 normal, vec3 rayDir, float materialID) {
            vec3 lightPos = vec3(5.0 * cos(u_time * 0.3), 5.0, 5.0 * sin(u_time * 0.3));
            vec3 lightDir = normalize(lightPos - p);
            vec3 viewDir = -rayDir; 

            vec3 materialColor = vec3(0.6); 
            if (materialID == 0.0) materialColor = vec3(0.4, 0.5, 0.3); 
            if (materialID == 1.0) materialColor = vec3(0.8, 0.2, 0.2); 
            if (materialID == 2.0) materialColor = vec3(0.2, 0.2, 0.8); 
            if (materialID == 3.0) materialColor = vec3(0.8, 0.8, 0.2); 
            if (materialID == 4.0) materialColor = vec3(0.9, 0.15, 0.4); // Heart: deep pink/magenta

            float ambientStrength = 0.2;
            vec3 ambient = ambientStrength * materialColor;

            float diff = max(dot(normal, lightDir), 0.0);
            vec3 diffuse = diff * materialColor;

            float specularStrength = 0.8;
            vec3 reflectDir = reflect(-lightDir, normal);
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
            vec3 specular = specularStrength * spec * vec3(1.0); 

            float shadow = 1.0;
            vec3 shadowRayOrigin = p + normal * (HIT_THRESHOLD * 10.0); 
            vec2 shadowRes = raymarch(shadowRayOrigin, lightDir);
            if (shadowRes.x < length(lightPos - shadowRayOrigin) && shadowRes.y > -0.5) { 
                shadow = 0.3; 
            }

            return ambient + (diffuse + specular) * shadow;
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;

            vec3 rayOrigin = u_cameraPos;
            vec3 rayDirection = getRayDirection(uv, u_cameraPos, u_cameraLookAt, u_cameraZoom);

            vec2 hitResult = raymarch(rayOrigin, rayDirection);
            float distToSurface = hitResult.x;
            float materialID_hit = hitResult.y; // Renamed to avoid conflict with map's materialID

            vec3 color;
            if (materialID_hit > -0.5) { 
                vec3 hitPoint = rayOrigin + rayDirection * distToSurface;
                vec3 normal = calcNormal(hitPoint);
                color = applyLighting(hitPoint, normal, rayDirection, materialID_hit);

                float fogAmount = smoothstep(10.0, 30.0, distToSurface); 
                color = mix(color, vec3(0.5, 0.6, 0.7), fogAmount); 

            } else { 
                color = vec3(0.5, 0.6, 0.7) - max(rayDirection.y, 0.0) * 0.2; 
            }

            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        let gl;
        let program;
        let positionBuffer;
        let resolutionUniformLocation;
        let timeUniformLocation;
        let cameraPosUniformLocation;
        let cameraLookAtUniformLocation;
        let cameraZoomUniformLocation;

        let camera = {
            azimuth: Math.PI / 4,
            elevation: Math.PI / 6,
            distance: 10.0,
            lookAt: [0, 0.5, 0], 
            zoom: 2.0 
        };

        let mouse = {
            lastX: 0,
            lastY: 0,
            dragging: false
        };

        function main() {
            const canvas = document.getElementById('glcanvas');
            gl = canvas.getContext('webgl');
            if (!gl) {
                alert('WebGL not supported!');
                return;
            }

            const vertexShaderSource = document.getElementById('vertex-shader').text;
            const fragmentShaderSource = document.getElementById('fragment-shader').text;

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            if (!vertexShader || !fragmentShader) return;

            program = createProgram(gl, vertexShader, fragmentShader);
            if (!program) return;

            const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
            resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');
            timeUniformLocation = gl.getUniformLocation(program, 'u_time');
            cameraPosUniformLocation = gl.getUniformLocation(program, 'u_cameraPos');
            cameraLookAtUniformLocation = gl.getUniformLocation(program, 'u_cameraLookAt');
            cameraZoomUniformLocation = gl.getUniformLocation(program, 'u_cameraZoom');

            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            canvas.addEventListener('mousedown', (e) => {
                mouse.dragging = true;
                mouse.lastX = e.clientX;
                mouse.lastY = e.clientY;
            });
            canvas.addEventListener('mouseup', () => {
                mouse.dragging = false;
            });
            canvas.addEventListener('mousemove', (e) => {
                if (mouse.dragging) {
                    const dx = (e.clientX - mouse.lastX) * 0.01;
                    const dy = (e.clientY - mouse.lastY) * 0.01;
                    
                    camera.azimuth -= dx;
                    camera.elevation += dy;
                    camera.elevation = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, camera.elevation));

                    mouse.lastX = e.clientX;
                    mouse.lastY = e.clientY;
                }
            });
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.distance += e.deltaY * 0.01;
                camera.distance = Math.max(1.0, Math.min(50.0, camera.distance));
            });

            requestAnimationFrame(render);
        }

        function render(time) {
            time *= 0.001; 

            if (resizeCanvasToDisplaySize(gl.canvas, window.devicePixelRatio || 1)) {
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            }

            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            gl.enableVertexAttribArray(0); 
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            const camX = camera.lookAt[0] + camera.distance * Math.cos(camera.elevation) * Math.sin(camera.azimuth);
            const camY = camera.lookAt[1] + camera.distance * Math.sin(camera.elevation);
            const camZ = camera.lookAt[2] + camera.distance * Math.cos(camera.elevation) * Math.cos(camera.azimuth);
            const camPos = [camX, camY, camZ];

            gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(timeUniformLocation, time);
            gl.uniform3fv(cameraPosUniformLocation, camPos);
            gl.uniform3fv(cameraLookAtUniformLocation, camera.lookAt);
            gl.uniform1f(cameraZoomUniformLocation, camera.zoom);

            gl.drawArrays(gl.TRIANGLES, 0, 6); 

            requestAnimationFrame(render);
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) {
                return shader;
            }
            console.error((type === gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT") + " SHADER COMPILE ERROR:\n" + gl.getShaderInfoLog(shader) + "\nSource:\n" + source.split('\n').map((l,i) => `${i+1}: ${l}`).join('\n'));
            gl.deleteShader(shader);
            return null;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            const success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (success) {
                return program;
            }
            console.error("PROGRAM LINK ERROR:", gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        
        function resizeCanvasToDisplaySize(canvas, multiplier) {
            multiplier = multiplier || 1;
            const width  = Math.floor(canvas.clientWidth  * multiplier);
            const height = Math.floor(canvas.clientHeight * multiplier);
            if (canvas.width  !== width || canvas.height !== height) {
                canvas.width  = width;
                canvas.height = height;
                return true;
            }
            return false;
        }

        window.onload = main;
    </script>
</body>
</html>
